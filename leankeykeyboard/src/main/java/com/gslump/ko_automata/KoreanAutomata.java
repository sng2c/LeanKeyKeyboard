/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.gslump.ko_automata;

import java.util.*;

import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.FIRST;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.INIT;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.LAST1;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.LAST2;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.MIDDLE1;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.MIDDLE2;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.SINGLE_MIDDLE1;
import static com.gslump.ko_automata.KoreanAutomata.ComposingFsm.ComposingStatePrefix.SINGLE_MIDDLE2;


public class KoreanAutomata {
    private static final ComposingFsm fsm = new ComposingFsm();
    private final ComposingContext context;
    public static final String BACKSPACE = String.valueOf((char) 0x08);

    public ComposingContext getContext() {
        return context;
    }

    public KoreanAutomata() {
        context = new ComposingContext();
    }
    public boolean isComposing(){
        return context.getStatePrefix() != INIT;
    }
    public Output type(String ch) {
        return type(context, ch);
    }

    public static Output type(ComposingContext context, String ch) {
        String commit = null;
        String compose = null;
        while (ch != null) {
            if (BACKSPACE.equals(ch)) {
                return typeBackspace(context);
            }

            if (!ComposingContext.isHangulTyping(ch)) {
                commit = context.compose();
                if (commit == null) {
                    commit = ch;
                }
                else{
                    commit = context.compose() + ch;
                }
                context.reset();
                break;
            }
            ComposingFsm.State oldState = context.getState();
            ComposingFsm.State newState = fsm.transit(oldState, ch);

            if (newState == null) {
                commit = context.compose();
                context.reset();
            } else if (oldState.state == LAST1 && newState.state == MIDDLE1) {
                String last = context.get(LAST1);
                if (context.isEmpty(MIDDLE2)) {
                    context.setStatePrefix(MIDDLE1);
                } else {
                    context.setStatePrefix(MIDDLE2);
                }
                commit = context.compose();

                context.reset();
                context.setStatePrefix(MIDDLE1);
                context.set(FIRST, last);
                context.set(MIDDLE1, ch);
                compose = context.compose();
                ch = null;
            } else if (oldState.state == LAST2 && newState.state == MIDDLE1) {
                String last = context.get(LAST2);
                context.setStatePrefix(LAST1);
                commit = context.compose();

                context.reset();
                context.setStatePrefix(MIDDLE1);
                context.set(FIRST, last);
                context.set(MIDDLE1, ch);
                compose = context.compose();
                ch = null;
            } else {
                context.applyState(newState);
                compose = context.compose();
                ch = null;
            }
        }
        return new Output(commit, compose);

    }
    public Output finish(){
        return finish(context);
    }
    public static Output finish(ComposingContext context){
        String ci = context.compose();
        context.reset();
        return new Output(ci, null);
    }
    public Output typeBackspace() {
        return typeBackspace(context);
    }
    public static Output typeBackspace(ComposingContext context) {
        String ci = null;
        String co = null;
        switch (context.getStatePrefix()){
            case FIRST:
            case SINGLE_MIDDLE1:
                context.reset();
                break;
            case SINGLE_MIDDLE2:
                context.setStatePrefix(SINGLE_MIDDLE1);
                co = context.compose();
                break;
            case MIDDLE1:
                context.setStatePrefix(FIRST);
                co = context.compose();
                break;
            case MIDDLE2:
                context.setStatePrefix(MIDDLE1);
                co = context.compose();
                break;
            case LAST1:
                if (context.isEmpty(MIDDLE2)) {
                    context.setStatePrefix(MIDDLE1);
                }else{
                    context.setStatePrefix(MIDDLE2);
                }
                co = context.compose();
                break;
            case LAST2:
                context.setStatePrefix(LAST1);
                co = context.compose();
                break;
            default:
                ci = BACKSPACE;
                context.reset();
                break;
        }
        return new Output(ci, co);
    }

    public static class ComposingFsm {

        final Map<Route, State> fsm = new HashMap<>();

        public ComposingFsm() {
            init();
        }

        private void init() {
            Set<String> fst = new HashSet<>(Arrays.asList("ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㄲㄸㅃㅆㅉ".split("")));
            Set<String> mid = new HashSet<>(Arrays.asList("ㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣㅐㅒㅔㅖ".split("")));
            Map<String, Set<String>> midmap = new HashMap<>();
            midmap.put("ㅗ", new HashSet<>(Arrays.asList("ㅏㅐㅣ".split(""))));
            midmap.put("ㅜ", new HashSet<>(Arrays.asList("ㅓㅔㅣ".split(""))));
            midmap.put("ㅡ", new HashSet<>(Arrays.asList("ㅣ".split(""))));

            Set<String> lst = new HashSet<>(Arrays.asList("ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㄲㅆ".split("")));
            Map<String, Set<String>> lstmap = new HashMap<>();
            lstmap.put("ㄱ", new HashSet<>(Arrays.asList("ㅅ".split(""))));
            lstmap.put("ㄴ", new HashSet<>(Arrays.asList("ㅈㅎ".split(""))));
            lstmap.put("ㄹ", new HashSet<>(Arrays.asList("ㄱㅁㅂㅅㅌㅎ".split(""))));
            lstmap.put("ㅂ", new HashSet<>(Arrays.asList("ㅅ".split(""))));

            //for m in mid:
            //    fsm[((None,''),m)] = ('JUNG3',m)
            //
            for (String m : mid) {
                fsm.put(Route.of(INIT, null, m), State.of(SINGLE_MIDDLE1, m));
            }

            //for m in midmap:
            //    for mm in midmap[m]:
            //        fsm[(('JUNG3',m), mm)] = ('JUNG4', mm)
            //
            for (String m : midmap.keySet()) {
                for (String mm : midmap.get(m)) {
                    fsm.put(Route.of(SINGLE_MIDDLE1, m, mm), State.of(SINGLE_MIDDLE2, mm));
                }
            }

            //for f in fst:
            //    fsm[((None,''),f)] = ('CHO',f)
            //
            for (String f : fst) {
                fsm.put(Route.of(INIT, null, f), State.of(FIRST, f));
            }

            //for f in fst:
            //    for m in mid:
            //        fsm[(('CHO',f),m)] = ('JUNG1',m)
            //
            for (String f : fst) {
                for (String m : mid) {
                    fsm.put(Route.of(FIRST, f, m), State.of(MIDDLE1, m));
                }
            }

            //for m in mid:
            //    for l in lst:
            //        fsm[(('JUNG1',m),l)] = ('JONG1',l)
            //
            for (String m : mid) {
                for (String l : lst) {
                    fsm.put(Route.of(MIDDLE1, m, l), State.of(LAST1, l));
                }
            }

            //for m in midmap:
            //    for mm in midmap[m]:
            //        fsm[(('JUNG1',m), mm)] = ('JUNG2', mm)
            //
            for (String m : midmap.keySet()) {
                for (String mm : midmap.get(m)) {
                    fsm.put(Route.of(MIDDLE1, m, mm), State.of(MIDDLE2, mm));
                }
            }
            //for m in midmap:
            //    for mm in midmap[m]:
            //        for l in lst:
            //            fsm[(('JUNG2', mm),l)] = ('JONG1',l)
            //
            for (String m : midmap.keySet()) {
                for (String mm : midmap.get(m)) {
                    for (String l : lst) {
                        fsm.put(Route.of(MIDDLE2, mm, l), State.of(LAST1, l));
                    }
                }
            }
            //for l in lstmap:
            //    for ll in lstmap[l]:
            //        fsm[(('JONG1',l),ll)] = ('JONG2',ll)
            //
            for (String l : lstmap.keySet()) {
                for (String ll : lstmap.get(l)) {
                    fsm.put(Route.of(LAST1, l, ll), State.of(LAST2, ll));
                }
            }

            //for l in lst:
            //    for m in mid:
            //        fsm[(('JONG1',l),m)] = ('JUNG1',m)
            //
            for (String l : lst) {
                for (String m : mid) {
                    fsm.put(Route.of(LAST1, l, m), State.of(MIDDLE1, m));
                }
            }
            //for l in lstmap:
            //    for ll in lstmap[l]:
            //        for m in mid:
            //            fsm[(('JONG2',ll),m)] = ('JUNG1',m)
            for (String l : lstmap.keySet()) {
                for (String ll : lstmap.get(l)) {
                    for (String m : mid) {
                        fsm.put(Route.of(LAST2, ll, m), State.of(MIDDLE1, m));
                    }
                }
            }
        }

        public State transit(State state, String ch) {
            return fsm.get(new Route(state, ch));
        }

        public enum ComposingStatePrefix {
            INIT, FIRST, MIDDLE1, MIDDLE2, LAST1, LAST2,
            SINGLE_MIDDLE1, SINGLE_MIDDLE2
        }

        public static class Route {
            State state;
            String newCh;

            public Route(State state, String newCh) {
                this.state = state;
                this.newCh = newCh;
            }

            public static Route of(ComposingStatePrefix hcstate, String ch, String newch) {
                return new Route(new State(hcstate, ch), newch);
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                Route that = (Route) o;
                return Objects.equals(state, that.state) && Objects.equals(newCh, that.newCh);
            }

            @Override
            public int hashCode() {
                return Objects.hash(state, newCh);
            }

            @Override
            public String toString() {
                return "Route{" +
                        "state=" + state +
                        ", newCh='" + newCh + '\'' +
                        '}';
            }
        }

        public static class State {
            ComposingStatePrefix state;
            String ch;

            public State(ComposingStatePrefix state, String ch) {
                this.state = state;
                this.ch = ch;
            }

            public static State of(ComposingStatePrefix state, String ch) {
                return new State(state, ch);
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                State state1 = (State) o;
                return state == state1.state && Objects.equals(ch, state1.ch);
            }

            @Override
            public int hashCode() {
                return Objects.hash(state, ch);
            }

            @Override
            public String toString() {
                return "State{" +
                        "state=" + state +
                        ", ch='" + ch + '\'' +
                        '}';
            }
        }
    }

    public static class ComposingContext {
        public static Set<String> inputs = new HashSet<>(Arrays.asList("ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㄲㄸㅃㅆㅉㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣㅐㅒㅔㅖ".split("")));
        private final String[] first = new String[1];
        private final String[] middle = new String[2];
        private final String[] last = new String[2];
        private ComposingFsm.ComposingStatePrefix statePrefix;

        public ComposingContext() {
            this.statePrefix = INIT;
            reset();
        }

        public static boolean isHangulTyping(String ch) {
            return inputs.contains(ch);
        }

        public ComposingFsm.ComposingStatePrefix getStatePrefix() {
            return statePrefix;
        }

        public void setStatePrefix(ComposingFsm.ComposingStatePrefix statePrefix) {
            this.statePrefix = statePrefix;
        }

        public void applyState(ComposingFsm.State state) {
            this.statePrefix = state.state;
            this.set(state.state, state.ch);
        }

        public void set(ComposingFsm.ComposingStatePrefix prefix, String value) {
            switch (prefix) {
                case INIT:
                    break;
                case FIRST:
                    first[0] = value;
                    break;
                case MIDDLE1:
                case SINGLE_MIDDLE1:
                    middle[0] = value;
                    break;
                case MIDDLE2:
                case SINGLE_MIDDLE2:
                    middle[1] = value;
                    break;
                case LAST1:
                    last[0] = value;
                    break;
                case LAST2:
                    last[1] = value;
                    break;
            }
        }

        public boolean isEmpty(ComposingFsm.ComposingStatePrefix prefix) {
            String v = get(prefix);
            return v == null || v.length() == 0;
        }

        public String get(ComposingFsm.ComposingStatePrefix prefix) {
            switch (prefix) {
                case INIT:
                    break;
                case FIRST:
                    return first[0];
                case MIDDLE1:
                case SINGLE_MIDDLE1:
                    return middle[0];
                case MIDDLE2:
                case SINGLE_MIDDLE2:
                    return middle[1];
                case LAST1:
                    return last[0];
                case LAST2:
                    return last[1];
            }
            return null;
        }

        public void reset() {
            this.statePrefix = INIT;
            first[0] = "";
            middle[0] = "";
            middle[1] = "";
            last[0] = "";
            last[1] = "";
        }

        public String compose() {
            String strFirst = "";
            String strMiddle = "";
            String strLast = "";

            switch (statePrefix) {
                case FIRST:
                    strFirst = first[0];
                    break;
                case MIDDLE1:
                    strFirst = first[0];
                    strMiddle = middle[0];
                    break;
                case MIDDLE2:
                    strFirst = first[0];
                    strMiddle = middle[0] + middle[1];
                    break;
                case SINGLE_MIDDLE1:
                    strMiddle = middle[0];
                    break;
                case SINGLE_MIDDLE2:
                    strMiddle = middle[0] + middle[1];
                    break;
                case LAST1:
                    strFirst = first[0];
                    strMiddle = middle[0] + middle[1];
                    strLast = last[0];
                    break;
                case LAST2:
                    strFirst = first[0];
                    strMiddle = middle[0] + middle[1];
                    strLast = last[0] + last[1];
                    break;
                default:
                    return null;
            }

            return HangulSymbol.compose(strFirst, strMiddle, strLast);
        }

        public ComposingFsm.State getState() {
            return ComposingFsm.State.of(statePrefix, get(statePrefix));
        }

        @Override
        public String toString() {
            return "ComposingContext{" +
                    "statePrefix=" + statePrefix +
                    ", first=" + Arrays.toString(first) +
                    ", middle=" + Arrays.toString(middle) +
                    ", last=" + Arrays.toString(last) +
                    '}';
        }
    }

    public static final class Output {
        private final CharSequence commited;
        private final CharSequence composing;

        public Output(CharSequence commited, CharSequence composing) {
            this.commited = commited;
            this.composing = composing;
        }

        public CharSequence getComposing() {
            return composing;
        }

        public CharSequence getCommitted() {
            return commited;
        }

        @Override
        public String toString() {
            return "Output{" +
                    "commited=" + commited +
                    ", composing=" + composing +
                    '}';
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Output output = (Output) o;
            return Objects.equals(commited, output.commited) && Objects.equals(composing, output.composing);
        }

        @Override
        public int hashCode() {
            return Objects.hash(commited, composing);
        }
    }
}
